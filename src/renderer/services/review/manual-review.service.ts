/**
 * Manual Review and Handoff Workflow Service
 * Manages human verification of uncertain matches with comprehensive workflow
 */

import { CompetitorProduct, OurProduct, MatchResult } from '@shared/types/matching.types';
import { ProductResearchResult } from '../research/web-search.service';

export interface ReviewItem {
  id: string;
  competitorProduct: CompetitorProduct;
  suggestedMatches: MatchResult[];
  researchData?: ProductResearchResult;
  priority: 'urgent' | 'high' | 'medium' | 'low';
  status: 'pending' | 'in_review' | 'approved' | 'rejected' | 'needs_more_info';
  assignedTo?: string;
  createdAt: Date;
  lastModified: Date;
  notes: ReviewNote[];
  flags: ReviewFlag[];
  estimatedReviewTime: number; // minutes
  actualReviewTime?: number;
}

export interface ReviewNote {
  id: string;
  author: string;
  content: string;
  type: 'comment' | 'question' | 'decision' | 'research_note';
  timestamp: Date;
  attachments?: string[];
}

export interface ReviewFlag {
  type: 'price_anomaly' | 'spec_mismatch' | 'brand_inconsistency' | 'missing_data' | 'conflict' | 'urgent';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  autoGenerated: boolean;
  resolvedAt?: Date;
  resolvedBy?: string;
}

export interface ReviewDecision {
  reviewItemId: string;
  decision: 'approve' | 'reject' | 'request_research' | 'escalate';
  selectedMatch?: MatchResult;
  customMatch?: {
    ourSku: string;
    confidence: number;
    reasoning: string[];
  };
  notes: string;
  reviewedBy: string;
  reviewedAt: Date;
  reviewTimeMinutes: number;
}

export interface ReviewQueue {
  pending: ReviewItem[];
  inReview: ReviewItem[];
  completed: ReviewItem[];
  totalCount: number;
  averageReviewTime: number;
  pendingHighPriority: number;
}

export interface ReviewerStats {
  reviewer: string;
  itemsReviewed: number;
  averageReviewTime: number;
  approvalRate: number;
  accuracyScore: number; // Based on later validation
  specializations: string[]; // Product types they're best at
}

export class ManualReviewService {
  private reviewQueue = new Map<string, ReviewItem>();
  private reviewerStats = new Map<string, ReviewerStats>();
  private reviewHistory: ReviewDecision[] = [];

  /**
   * Add item to review queue
   */
  async addToReviewQueue(
    competitorProduct: CompetitorProduct,
    suggestedMatches: MatchResult[],
    researchData?: ProductResearchResult,
    priority: ReviewItem['priority'] = 'medium'
  ): Promise<string> {
    const reviewItem: ReviewItem = {
      id: this.generateReviewId(),
      competitorProduct,
      suggestedMatches,
      researchData,
      priority,
      status: 'pending',
      createdAt: new Date(),
      lastModified: new Date(),
      notes: [],
      flags: this.generateAutomaticFlags(competitorProduct, suggestedMatches, researchData),
      estimatedReviewTime: this.estimateReviewTime(competitorProduct, suggestedMatches, researchData)
    };

    this.reviewQueue.set(reviewItem.id, reviewItem);
    await this.persistReviewItem(reviewItem);

    // Notify reviewers if high priority
    if (priority === 'urgent' || priority === 'high') {
      await this.notifyReviewers(reviewItem);
    }

    return reviewItem.id;
  }

  /**
   * Get review queue with intelligent prioritization
   */
  async getReviewQueue(reviewer?: string): Promise<ReviewQueue> {
    const items = Array.from(this.reviewQueue.values());
    
    // Filter by reviewer specialization if provided
    const filteredItems = reviewer ? 
      this.filterByReviewerExpertise(items, reviewer) : items;

    const pending = filteredItems
      .filter(item => item.status === 'pending')
      .sort(this.getItemSortFunction());

    const inReview = filteredItems.filter(item => item.status === 'in_review');
    const completed = filteredItems.filter(item => 
      ['approved', 'rejected'].includes(item.status)
    );

    const totalCount = items.length;
    const averageReviewTime = this.calculateAverageReviewTime();
    const pendingHighPriority = pending.filter(item => 
      ['urgent', 'high'].includes(item.priority)
    ).length;

    return {
      pending,
      inReview,
      completed,
      totalCount,
      averageReviewTime,
      pendingHighPriority
    };
  }

  /**
   * Claim review item for review
   */
  async claimReviewItem(reviewItemId: string, reviewer: string): Promise<ReviewItem | null> {
    const item = this.reviewQueue.get(reviewItemId);
    if (!item || item.status !== 'pending') {
      return null;
    }

    item.status = 'in_review';
    item.assignedTo = reviewer;
    item.lastModified = new Date();

    await this.addReviewNote(reviewItemId, {
      author: 'system',
      content: `Item claimed by ${reviewer}`,
      type: 'comment',
      timestamp: new Date()
    });

    await this.persistReviewItem(item);
    return item;
  }

  /**
   * Submit review decision
   */
  async submitReviewDecision(decision: ReviewDecision): Promise<void> {
    const item = this.reviewQueue.get(decision.reviewItemId);
    if (!item) {
      throw new Error('Review item not found');
    }

    // Update item status
    switch (decision.decision) {
      case 'approve':
        item.status = 'approved';
        break;
      case 'reject':
        item.status = 'rejected';
        break;
      case 'request_research':
        item.status = 'pending';
        item.priority = 'high';
        await this.requestAdditionalResearch(item);
        break;
      case 'escalate':
        item.priority = 'urgent';
        await this.escalateToExpert(item);
        break;
    }

    item.lastModified = new Date();
    item.actualReviewTime = decision.reviewTimeMinutes;

    // Add decision note
    await this.addReviewNote(decision.reviewItemId, {
      author: decision.reviewedBy,
      content: `Decision: ${decision.decision}\n${decision.notes}`,
      type: 'decision',
      timestamp: decision.reviewedAt
    });

    // Record decision in history
    this.reviewHistory.push(decision);

    // Update reviewer stats
    await this.updateReviewerStats(decision);

    // Process approved matches
    if (decision.decision === 'approve') {
      await this.processApprovedMatch(item, decision);
    }

    await this.persistReviewItem(item);
  }

  /**
   * Add note to review item
   */
  async addReviewNote(
    reviewItemId: string, 
    noteData: Omit<ReviewNote, 'id'>
  ): Promise<void> {
    const item = this.reviewQueue.get(reviewItemId);
    if (!item) return;

    const note: ReviewNote = {
      id: this.generateNoteId(),
      ...noteData
    };

    item.notes.push(note);
    item.lastModified = new Date();

    await this.persistReviewItem(item);
  }

  /**
   * Get review item with full context
   */
  async getReviewItemWithContext(reviewItemId: string): Promise<{
    item: ReviewItem;
    similarItems: ReviewItem[];
    historicalDecisions: ReviewDecision[];
    suggestedActions: string[];
  } | null> {
    const item = this.reviewQueue.get(reviewItemId);
    if (!item) return null;

    // Find similar items for context
    const similarItems = await this.findSimilarReviewItems(item);

    // Get historical decisions for similar products
    const historicalDecisions = this.getHistoricalDecisions(item.competitorProduct);

    // Generate suggested actions
    const suggestedActions = this.generateSuggestedActions(item, similarItems, historicalDecisions);

    return {
      item,
      similarItems,
      historicalDecisions,
      suggestedActions
    };
  }

  /**
   * Get reviewer performance statistics
   */
  async getReviewerStats(reviewer?: string): Promise<ReviewerStats[]> {
    if (reviewer) {
      const stats = this.reviewerStats.get(reviewer);
      return stats ? [stats] : [];
    }

    return Array.from(this.reviewerStats.values())
      .sort((a, b) => b.accuracyScore - a.accuracyScore);
  }

  /**
   * Generate comprehensive review report
   */
  async generateReviewReport(timeframe: { start: Date; end: Date }): Promise<{
    summary: {
      totalReviewed: number;
      approvalRate: number;
      averageReviewTime: number;
      backlogSize: number;
    };
    byPriority: Record<string, number>;
    byReviewer: ReviewerStats[];
    flagAnalysis: Array<{ flag: string; count: number; resolutionRate: number }>;
    trends: Array<{ date: string; reviewed: number; approved: number }>;
  }> {
    const decisions = this.reviewHistory.filter(d => 
      d.reviewedAt >= timeframe.start && d.reviewedAt <= timeframe.end
    );

    const summary = {
      totalReviewed: decisions.length,
      approvalRate: decisions.filter(d => d.decision === 'approve').length / decisions.length,
      averageReviewTime: decisions.reduce((sum, d) => sum + d.reviewTimeMinutes, 0) / decisions.length,
      backlogSize: Array.from(this.reviewQueue.values()).filter(i => i.status === 'pending').length
    };

    // Analysis by priority
    const byPriority: Record<string, number> = {};
    Array.from(this.reviewQueue.values()).forEach(item => {
      byPriority[item.priority] = (byPriority[item.priority] || 0) + 1;
    });

    // Reviewer performance
    const byReviewer = await this.getReviewerStats();

    // Flag analysis
    const flagCounts = new Map<string, { count: number; resolved: number }>();
    Array.from(this.reviewQueue.values()).forEach(item => {
      item.flags.forEach(flag => {
        const current = flagCounts.get(flag.type) || { count: 0, resolved: 0 };
        current.count++;
        if (flag.resolvedAt) current.resolved++;
        flagCounts.set(flag.type, current);
      });
    });

    const flagAnalysis = Array.from(flagCounts.entries()).map(([flag, data]) => ({
      flag,
      count: data.count,
      resolutionRate: data.count > 0 ? data.resolved / data.count : 0
    }));

    // Trends (simplified - would be more sophisticated in real implementation)
    const trends: Array<{ date: string; reviewed: number; approved: number }> = [];

    return {
      summary,
      byPriority,
      byReviewer,
      flagAnalysis,
      trends
    };
  }

  // Private helper methods

  private generateReviewId(): string {
    return `review_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateNoteId(): string {
    return `note_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
  }

  private generateAutomaticFlags(
    competitorProduct: CompetitorProduct,
    suggestedMatches: MatchResult[],
    researchData?: ProductResearchResult
  ): ReviewFlag[] {
    const flags: ReviewFlag[] = [];

    // Price anomaly detection
    if (competitorProduct.price) {
      const price = competitorProduct.price;
      if (price < 100 || price > 10000) {
        flags.push({
          type: 'price_anomaly',
          severity: price < 50 || price > 15000 ? 'critical' : 'medium',
          description: `Unusual price: $${price}`,
          autoGenerated: true
        });
      }
    }

    // Low confidence matches
    const maxConfidence = Math.max(...suggestedMatches.map(m => m.confidence), 0);
    if (maxConfidence < 0.6) {
      flags.push({
        type: 'spec_mismatch',
        severity: maxConfidence < 0.4 ? 'high' : 'medium',
        description: `Low match confidence: ${(maxConfidence * 100).toFixed(0)}%`,
        autoGenerated: true
      });
    }

    // Missing critical data
    if (!competitorProduct.specifications || Object.keys(competitorProduct.specifications).length < 2) {
      flags.push({
        type: 'missing_data',
        severity: 'medium',
        description: 'Limited specification data available',
        autoGenerated: true
      });
    }

    // Research conflicts
    if (researchData?.needsManualReview) {
      flags.push({
        type: 'conflict',
        severity: 'high',
        description: 'Research found conflicting information',
        autoGenerated: true
      });
    }

    return flags;
  }

  private estimateReviewTime(
    competitorProduct: CompetitorProduct,
    suggestedMatches: MatchResult[],
    researchData?: ProductResearchResult
  ): number {
    let baseTime = 5; // Base 5 minutes

    // Add time for complexity factors
    if (suggestedMatches.length === 0) baseTime += 10; // No matches = more research needed
    if (suggestedMatches.length > 5) baseTime += 5; // Many matches = more comparison needed
    if (researchData && researchData.searchResults.length > 10) baseTime += 5; // Lots of research data
    if (!competitorProduct.specifications) baseTime += 8; // Missing specs = more investigation

    return baseTime;
  }

  private getItemSortFunction() {
    const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 };
    
    return (a: ReviewItem, b: ReviewItem) => {
      // Sort by priority first
      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];
      if (priorityDiff !== 0) return priorityDiff;

      // Then by age (older items first)
      return a.createdAt.getTime() - b.createdAt.getTime();
    };
  }

  private filterByReviewerExpertise(items: ReviewItem[], reviewer: string): ReviewItem[] {
    const stats = this.reviewerStats.get(reviewer);
    if (!stats || stats.specializations.length === 0) {
      return items; // No specialization data, return all items
    }

    // Prioritize items matching reviewer's specializations
    return items.sort((a, b) => {
      const aMatch = this.matchesSpecialization(a, stats.specializations);
      const bMatch = this.matchesSpecialization(b, stats.specializations);
      
      if (aMatch && !bMatch) return -1;
      if (!aMatch && bMatch) return 1;
      return 0;
    });
  }

  private matchesSpecialization(item: ReviewItem, specializations: string[]): boolean {
    const productType = this.extractProductType(item.competitorProduct);
    return specializations.includes(productType);
  }

  private extractProductType(product: CompetitorProduct): string {
    const desc = (product.description || '').toLowerCase();
    if (desc.includes('furnace')) return 'furnace';
    if (desc.includes('heat pump')) return 'heat_pump';
    if (desc.includes('air condition')) return 'air_conditioner';
    if (desc.includes('coil')) return 'coil';
    return 'other';
  }

  private calculateAverageReviewTime(): number {
    const completedItems = Array.from(this.reviewQueue.values())
      .filter(item => item.actualReviewTime);
    
    if (completedItems.length === 0) return 10; // Default estimate

    const totalTime = completedItems.reduce((sum, item) => sum + (item.actualReviewTime || 0), 0);
    return totalTime / completedItems.length;
  }

  private async notifyReviewers(item: ReviewItem): Promise<void> {
    // Implementation would send notifications to available reviewers
    console.log(`Notifying reviewers about high priority item: ${item.id}`);
  }

  private async requestAdditionalResearch(item: ReviewItem): Promise<void> {
    // Implementation would trigger additional research
    console.log(`Requesting additional research for item: ${item.id}`);
  }

  private async escalateToExpert(item: ReviewItem): Promise<void> {
    // Implementation would escalate to senior reviewers
    console.log(`Escalating item to expert review: ${item.id}`);
  }

  private async updateReviewerStats(decision: ReviewDecision): Promise<void> {
    const reviewer = decision.reviewedBy;
    let stats = this.reviewerStats.get(reviewer);

    if (!stats) {
      stats = {
        reviewer,
        itemsReviewed: 0,
        averageReviewTime: 0,
        approvalRate: 0,
        accuracyScore: 1.0,
        specializations: []
      };
    }

    // Update basic stats
    const oldCount = stats.itemsReviewed;
    stats.itemsReviewed++;
    stats.averageReviewTime = 
      (stats.averageReviewTime * oldCount + decision.reviewTimeMinutes) / stats.itemsReviewed;

    const approvals = this.reviewHistory.filter(d => 
      d.reviewedBy === reviewer && d.decision === 'approve'
    ).length;
    stats.approvalRate = approvals / stats.itemsReviewed;

    this.reviewerStats.set(reviewer, stats);
  }

  private async processApprovedMatch(item: ReviewItem, decision: ReviewDecision): Promise<void> {
    // Implementation would save approved match to knowledge base
    console.log(`Processing approved match for item: ${item.id}`);
  }

  private async findSimilarReviewItems(item: ReviewItem): Promise<ReviewItem[]> {
    // Implementation would find similar items based on company, product type, etc.
    return [];
  }

  private getHistoricalDecisions(competitorProduct: CompetitorProduct): ReviewDecision[] {
    return this.reviewHistory.filter(d => 
      d.reviewItemId.includes(competitorProduct.company.toLowerCase())
    ).slice(-5); // Last 5 similar decisions
  }

  private generateSuggestedActions(
    item: ReviewItem,
    similarItems: ReviewItem[],
    historicalDecisions: ReviewDecision[]
  ): string[] {
    const suggestions: string[] = [];

    // Based on flags
    if (item.flags.some(f => f.type === 'missing_data')) {
      suggestions.push('Request additional product specifications');
    }

    if (item.flags.some(f => f.type === 'price_anomaly')) {
      suggestions.push('Verify pricing information with distributor');
    }

    // Based on historical patterns
    if (historicalDecisions.length > 0) {
      const approvalRate = historicalDecisions.filter(d => d.decision === 'approve').length / historicalDecisions.length;
      if (approvalRate > 0.8) {
        suggestions.push('Similar products usually approved - review for consistency');
      }
    }

    return suggestions;
  }

  private async persistReviewItem(item: ReviewItem): Promise<void> {
    // Implementation would save to database
    console.log(`Persisting review item: ${item.id}`);
  }
}